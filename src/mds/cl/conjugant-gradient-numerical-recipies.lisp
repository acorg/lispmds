(in-package user)

;; (require "f2cl_macros")

(defun mnbrak (ax bx cx fa fb fc func &key (gold 1.618034) (glimit 100.0) (tiny 1.0E-20))
;;  (declare (type double-float ax)) (declare (type double-float bx))
;;  (declare (type double-float cx)) (declare (type double-float fa))
;;  (declare (type double-float fb)) (declare (type double-float fc))
;;  (declare (type double-float gold)) (declare (type double-float glimit))
;;  (declare (type double-float tiny))
  (prog ((fu 0.0d0) (ulim 0.0d0) (u 0.0d0) (q 0.0d0) (r 0.0d0) (dum 0.0d0))
;;    (declare (type double-float fu)) (declare (type double-float ulim))
;;    (declare (type double-float u)) (declare (type double-float q))
;;    (declare (type double-float r)) (declare (type double-float dum))
    (setf fa (funcall func ax)) 
    (setf fb (funcall func bx))
    (cond ((> fb fa)
	   (setf dum ax)
	   (setf ax bx)
	   (setf bx dum)
	   (setf dum fb)
	   (setf fb fa)
	   (setf fa dum)
	   ))
    (setf cx (+ bx (* gold (+ bx (- ax)))))
    (setf fc (funcall func cx)) 
   label1
    (cond ((>= fb fc)   ;;  THIS IS A > IN THE C
	   (setf r (* (+ bx (- ax)) (+ fb (- fc))))
	   (setf q (* (+ bx (- cx)) (+ fb (- fa))))
	   (setf u
	     (+ bx
		(/ (* -1 (+ (* (+ bx (- cx)) q) (* (* -1 (+ bx (- ax))) r)))
		   (* 2.0 (fsign (max (abs (+ q (- r))) tiny) (+ q (- r)))))))  ;;was sign
	   (setf ulim (+ bx (* glimit (+ cx (- bx)))))
	   (cond ((> (* (+ bx (- u)) (+ u (- cx))) 0.0)
		  (setf fu (funcall func u))
		  (cond ((< fu fc)
			 (setf ax bx)
			 (setf fa fb)
			 (setf bx u)
			 (setf fb fu)
			 (go label1))  ;; causes a return
			((> fu fb)
			 (setf cx u)
			 (setf fc fu)
			 (go label1))) ;; causes a return
		  (setf u (+ cx (* gold (+ cx (- bx))))) 
		  (setf fu (funcall func u)))
		 ((> (* (+ cx (- u)) (+ u (- ulim))) 0.0)
		  (setf fu (funcall func u))
		  (cond ((< fu fc)
			 (setf bx cx)
			 (setf cx u)
			 (setf u (+ cx (* gold (+ cx (- bx)))))
			 (setf fb fc)
			 (setf fc fu)
			 (setf fu (funcall func u)))))
		 ((>= (* (+ u (- ulim)) (+ ulim (- cx))) 0.0)
		  (setf u ulim)
		  (setf fu (funcall func u)))
		 (t 
		  (setf u (+ cx (* gold (+ cx (- bx)))))
		  (setf fu (funcall func u))))
	   (setf ax bx) (setf bx cx) (setf cx u) 
	   (setf fa fb) (setf fb fc) (setf fc fu)
	   (go label1)
	   ))
    (return (values ax bx cx fa fb fc func))
    ))

(defun brent (ax bx cx f tol xmin &key (itmax 100) (cgold 0.381966) (zeps 1.0E-10))
;;  (declare (type double-float ax)) (declare (type double-float bx))
;;  (declare (type double-float cx)) (declare (type double-float tol))
;;  (declare (type double-float xmin)) (declare (type fixnum itmax))
;;  (declare (type double-float cgold)) (declare (type double-float zeps))
  (prog
      ((xbrent 0.0d0) (fu 0.0d0) (u 0.0d0) (d 0.0d0) (etemp 0.0d0) (p 0.0d0)
		      (q 0.0d0) (r 0.0d0) (tol2 0.0d0) (tol1 0.0d0) (xm 0.0d0) (iter 0) (fw 0.0d0)
		      (fv 0.0d0) (fx 0.0d0) (e 0.0d0) (x 0.0d0) (w 0.0d0) (v 0.0d0) (b 0.0d0)
		      (a 0.0d0)
		      )
;;    (declare (type double-float xbrent)) (declare (type double-float fu))
;;    (declare (type double-float u)) (declare (type double-float d))
;;    (declare (type double-float etemp)) (declare (type double-float p))
;;    (declare (type double-float q)) (declare (type double-float r))
;;    (declare (type double-float tol2)) (declare (type double-float tol1))
;;    (declare (type double-float xm)) (declare (type fixnum iter))
;;    (declare (type double-float fw)) (declare (type double-float fv))
;;    (declare (type double-float fx)) (declare (type double-float e))
;;    (declare (type double-float x)) (declare (type double-float w))
;;    (declare (type double-float v)) (declare (type double-float b))
;;    (declare (type double-float a)) 
    (setf a (min ax cx))
    (setf b (max ax cx))
    (setf v bx) (setf w v) (setf x v) 
    (setf e 0.0) 
    (setf fx (funcall f x))
    (setf fv fx) 
    (setf fw fx)
    (fdo ((iter 1 (+ iter 1))) ((> iter itmax) nil)
	 (tagbody 
	   (setf xm (* 0.5 (+ a b)))
	   (setf tol1 (+ (* tol (abs x)) zeps))
	   (setf tol2 (* 2.0 tol1))
	   (if (<= (abs (- x xm)) (- tol2 (* 0.5 (- b a)))) 
	       (go label3))
	   (cond ((> (abs e) tol1) 
		  (setf r (* (+ x (- w)) (+ fx (- fv))))
		  (setf q (* (+ x (- v)) (+ fx (- fw))))
		  (setf p (+ (* (+ x (- v)) q) (* (* -1 (+ x (- w))) r)))
		  (setf q (* 2.0 (+ q (- r)))) 
		  (if (> q 0.0) 
		      (setf p (- p)))
		  (setf q (abs q)) 
		  (setf etemp e) 
		  (setf e d)
		  (if (or (>= (abs p) (abs (* 0.5 q etemp)))
			  (<= p (* q (- a x)))
			  (>= p (* q (- b x))))
		      (go label1)
		    )
		  (setf d (/ p q)) 
		  (setf u (+ x d))
		  (if (or (< (+ u (- a)) tol2) 
			  (< (+ b (- u)) tol2))
		      (setf d (fsign tol1 (+ xm (- x))))  ;;was sign
		    )
		  (go label2)
		  ))
	  label1 
	   (cond ((>= x xm) (setf e (+ a (- x))))
		 (t (setf e (+ b (- x)))))
	   (setf d (* cgold e))
	  label2
	   (cond ((>= (abs d) tol1) (setf u (+ x d))) 
		 (t (setf u (+ x (fsign tol1 d)))))   ;;was sign
	   (setf fu (funcall f u))
	   (cond ((<= fu fx) 
		  (cond ((>= u x) (setf a x)) 
			(t (setf b x)))
		  (setf v w)
		  (setf fv fw) 
		  (setf w x)
		  (setf fw fx)
		  (setf x u)
		  (setf fx fu)
		  )
		 (t (cond ((< u x) (setf a u))
			  (t (setf b u)))
		    (cond ((or (<= fu fw) (= w x))
			   (setf v w) 
			   (setf fv fw)
			   (setf w u)
			   (setf fw fu))
			  ((or (<= fu fv) (= v x) (= v w))
			   (setf v u)
			   (setf fv fu))
			  )))))
    (error "Brent exceed maximum iterations.")
   label3
    (setf xmin x)
    (setf xbrent fx) 
    ;; (return xbrent)  derek
    (return (values xbrent xmin))   
    ))

;;derek added
;;these four are used by f1dim, and set in linmin
(defvar ncom)
(defvar pcom)
(defvar xicom)
(defvar nrfunc)

(defun f1dim (x)
;;  (declare (type double-float x))
  (prog
      ((xt (make-array (+ ncom 1) :element-type 'double-float))
       (f1dim 0.0d0)
       (j 0))
;;    (declare (type (simple-array double-float (*)) xt))
;;    (declare (type double-float f1dim)) 
;;    (declare (type fixnum j))
    (fdo ((j 1 (+ j 1))) ((> j ncom) nil)
	 (tagbody 
	   (fset-nm (fref xt j) (+ (fref pcom j) (* x (fref xicom j)))))
	 )
    (setf f1dim (funcall nrfunc xt)) 
    (return f1dim)
    ))

(defun linmin (p xi n fret func &key (tol 1.0E-4))
;; (declare (type (simple-array double-float (*)) p))
;; (declare (type (simple-array double-float (*)) xi)) 
;; (declare (type fixnum n))
;; (declare (type double-float fret))
;; (declare (type fixnum nmax))
;; (declare (type double-float tol))
 (prog ((xmin 0.0d0) (bx 0.0d0) (xx 0.0d0) (ax 0.0d0) (j 0) fa fx fb)
;;   (declare (type double-float xmin)) (declare (type double-float bx))
;;   (declare (type double-float xx)) (declare (type double-float ax))
;;   (declare (type fixnum j)) 
   
   (setq ncom n)
   (setq pcom (make-array n))
   (setq xicom (make-array n))
   (setq nrfunc func)

   (fdo ((j 1 (+ j 1))) ((> j n) nil)
	(tagbody 
	  (fset-nm (fref pcom j) (fref p j))
	  (fset-nm (fref xicom j) (fref xi j)))
	)
   (setf ax 0.0) 
   (setf xx 1.0)
   (setf bx 2.0)  ;; (derek) bx is not set in the c (but does not matter
                  ;; the call to mnbrak does not use the value before setting it

   (multiple-value-setq (ax xx bx fa fx fb) ;; f1dim)
     ;; (mnbrak ax xx bx fa fx fb f1dim)
     (mnbrak ax xx bx fa fx fb #'f1dim))

   ;; (setf fret (brent ax xx bx #'f1dim tol xmin))
   (multiple-value-setq (fret xmin) ;; derek, added xmin as return values from brent
     (brent ax xx bx #'f1dim tol xmin))

   (fdo ((j 1 (+ j 1))) ((> j n) nil)
	(tagbody 
	  (fset-nm (fref xi j) (* xmin (fref xi j)))
	  (fset-nm (fref p j) (+ (fref p j) (fref xi j)))
	  ))
   (return (values p xi n fret))
   ))

;; this is not hack integrated with conjugant-gradient-iterations
(defun frprmn (p n ftol iter fret func dfunc &key (itmax 200) (eps 1.0E-10))
  ;; iter and fret are returns
  (declare (type (simple-array double-float (*)) p)) (declare (type fixnum n))
  (declare (type double-float ftol)) (declare (type fixnum iter))
  (declare (type double-float fret)) (declare (type fixnum nmax))
  (declare (type fixnum itmax)) (declare (type double-float eps))
  (prog
      ((g (make-array (list (+ n 1)) :element-type 'double-float))
       (h (make-array (list (+ n 1)) :element-type 'double-float))
       (xi (make-array (list (+ n 1)) :element-type 'double-float)) 
       (gam 0.0d0) (dgg 0.0d0) (gg 0.0d0) (j 0) (fp 0.0d0)
       )
    (declare (type (simple-array double-float (*)) g))
    (declare (type (simple-array double-float (*)) h))
    (declare (type (simple-array double-float (*)) xi))
    (declare (type double-float gam)) (declare (type double-float dgg))
    (declare (type double-float gg)) (declare (type fixnum j))
    (declare (type double-float fp)) 
    (setf fp (funcall func p))
    (multiple-value-setq (p xi) (funcall dfunc p xi))
    (fdo ((j 1 (+ j 1))) ((> j n) nil)
	 (tagbody 
	   (fset-nm (fref g j) (- (fref xi j))) 
	   (fset-nm (fref h j) (fref g j))
	   (fset-nm (fref xi j) (fref h j))
	   ))
    (fdo ((iter 1 (+ iter 1))) ((> iter itmax) nil)
	 (tagbody 
	   (multiple-value-setq (p xi n fret) (linmin p xi n fret func))
	   (if (<= (* 2.0 (abs (+ fret (- fp)))) (* ftol (+ (+ (abs fret) (abs fp)) eps))
		   )
	       (go end_label)
	     )
	   (setf fp (funcall func p))   ;; there is an optimization here, to set fp to fret (in the c code)
	   (multiple-value-setq (p xi) (funcall dfunc p xi)) 
	   (setf gg 0.0)
	   (setf dgg 0.0)
	   (fdo ((j 1 (+ j 1))) ((> j n) nil)
		(tagbody 
		  (setf gg (+ gg (expt (fref g j) 2)))
		  (setf dgg (+ dgg (* (+ (fref xi j) (fref g j)) (fref xi j))))
		  ))
	   (if (= gg 0.0) (go end_label)) 
	   (setf gam (/ dgg gg))
	   (fdo ((j 1 (+ j 1))) ((> j n) nil)
		(tagbody 
		  (fset-nm (fref g j) (- (fref xi j)))
		  (fset-nm (fref h j) (+ (fref g j) (* gam (fref h j))))
		  (fset-nm (fref xi j) (fref h j))
		  ))))
    (error "FRPR maximum iterations exceeded") 
    (go end_label)
   end_label
    (return (values p n ftol iter fret))
    ))


